# GitHub Actions - Windows 11 ビルドワークフロー
# DN_SuperBook_PDF_Converter プロジェクト用
# ハイブリッド構成: GitHubランナー（ビルド）+ セルフホストランナー（デプロイ）

name: Build, Test and Deploy

on:
  push:
    branches:
      - "**"
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'build'
        type: choice
        options:
          - build
          - rollback
      pytorch_cuda:
        description: 'PyTorch CUDA version (requires compatible NVIDIA driver)'
        required: true
        default: 'cu126'
        type: choice
        options:
          - cu126
          - cu128
          - cu130

env:
  # デプロイ先フォルダ（セルフホストランナー上のパス）
  DEPLOY_PATH: 'C:\SuperBookTools'
  # バックアップフォルダ
  BACKUP_PATH: 'C:\SuperBookTools_Backup'
  # .NET バージョン
  DOTNET_VERSION: '6.0'
  # PyTorch CUDAバージョン（workflow_dispatchから選択、またはデフォルト値）
  # - cu126: CUDA 12.6 (推奨、ドライバー 525.60+)
  # - cu128: CUDA 12.8 (ドライバー 555.42+)
  # - cu130: CUDA 13.0 (最新、ドライバー 570+)
  PYTORCH_CUDA_VERSION: ${{ github.event.inputs.pytorch_cuda || 'cu126' }}

jobs:
  # ビルド・テストジョブ（GitHub提供ランナー）
  build:
    runs-on: windows-latest
    if: github.event.inputs.action != 'rollback'
    timeout-minutes: 30

    strategy:
      fail-fast: false
      matrix:
        configuration: [Debug, Release]

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Display .NET version
        run: dotnet --version

      - name: Restore dependencies
        run: dotnet restore DN_SuperBook_PDF_Converter_VS2026.sln

      - name: Build ${{ matrix.configuration }}
        run: dotnet build -c ${{ matrix.configuration }} -v normal DN_SuperBook_PDF_Converter_VS2026.sln --no-restore

      - name: Test ${{ matrix.configuration }}
        run: dotnet test -c ${{ matrix.configuration }} -v normal --logger:"console;verbosity=detailed" DN_SuperBook_PDF_Converter_VS2026.sln --no-build
        continue-on-error: true

      # Releaseビルドのみ: 自己完結型パッケージを作成
      - name: Publish self-contained application
        if: matrix.configuration == 'Release'
        run: |
          dotnet publish SuperBookToolsApp/SuperBookToolsApp.csproj `
            -c Release `
            -r win-x64 `
            --self-contained true `
            -o ./publish/win-x64

      # Releaseビルドのみ: アーティファクトをアップロード
      - name: Upload build artifacts
        if: matrix.configuration == 'Release'
        uses: actions/upload-artifact@v4
        with:
          name: SuperBookToolsApp-win-x64
          path: ./publish/win-x64/
          retention-days: 30

  # インストーラビルドジョブ（GitHub提供ランナー）
  build-installer:
    runs-on: windows-latest
    needs: build
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event.inputs.action != 'rollback'
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: SuperBookToolsApp-win-x64
          path: ./publish/win-x64

      - name: Setup external tools directory
        shell: pwsh
        run: |
          $toolsDir = "./installer/tools"
          New-Item -ItemType Directory -Path $toolsDir -Force | Out-Null

      - name: Download ExifTool
        shell: pwsh
        run: |
          $toolsPath = "./installer/tools/exiftool-13.30_64"
          New-Item -ItemType Directory -Path $toolsPath -Force | Out-Null
          
          $zipPath = Join-Path $env:TEMP "exiftool.zip"
          $tempExtract = Join-Path $env:TEMP "exiftool_extract"
          
          if (Test-Path $tempExtract) { Remove-Item -Recurse -Force $tempExtract }
          New-Item -ItemType Directory -Path $tempExtract -Force | Out-Null
          
          Invoke-WebRequest -Uri "https://filecenter.softether-upload.com/d/260118_003_73929/exiftool-13.30_64.zip" -OutFile $zipPath
          Expand-Archive -Path $zipPath -DestinationPath $tempExtract -Force
          
          $extractedSubDir = Join-Path $tempExtract "exiftool-13.30_64"
          if (Test-Path $extractedSubDir) {
            Copy-Item -Path "$extractedSubDir\*" -Destination $toolsPath -Recurse -Force
          } else {
            Copy-Item -Path "$tempExtract\*" -Destination $toolsPath -Recurse -Force
          }
          
          # exiftool(-k).exe を exiftool.exe にリネーム
          $srcExe = Join-Path $toolsPath "exiftool(-k).exe"
          if (Test-Path $srcExe) {
            Rename-Item -Path $srcExe -NewName "exiftool.exe" -Force
          }
          
          Remove-Item $zipPath -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force $tempExtract -ErrorAction SilentlyContinue
          Write-Host "✅ ExifTool downloaded"

      - name: Download ImageMagick
        shell: pwsh
        run: |
          $toolsPath = "./installer/tools/ImageMagick-portable-Q16-HDRI-x64"
          New-Item -ItemType Directory -Path $toolsPath -Force | Out-Null
          
          $binariesUrl = "https://imagemagick.org/archive/binaries/"
          $response = Invoke-WebRequest -Uri $binariesUrl -UseBasicParsing
          $pattern = 'ImageMagick-7\.1\.[\d\-]+-portable-Q16-HDRI-x64\.7z'
          $matches7z = [regex]::Matches($response.Content, $pattern)
          
          if ($matches7z.Count -gt 0) {
            $fileName = $matches7z[$matches7z.Count - 1].Value
          } else {
            $fileName = "ImageMagick-7.1.2-13-portable-Q16-HDRI-x64.7z"
          }
          
          $downloadPath = Join-Path $env:TEMP $fileName
          Invoke-WebRequest -Uri "$binariesUrl$fileName" -OutFile $downloadPath
          tar -xf $downloadPath -C $toolsPath
          Remove-Item $downloadPath -ErrorAction SilentlyContinue
          Write-Host "✅ ImageMagick downloaded"

      - name: Download pdfcpu
        shell: pwsh
        run: |
          $toolsPath = "./installer/tools/pdfcpu"
          New-Item -ItemType Directory -Path $toolsPath -Force | Out-Null
          
          $zipPath = Join-Path $env:TEMP "pdfcpu.zip"
          Invoke-WebRequest -Uri "https://github.com/pdfcpu/pdfcpu/releases/download/v0.11.0/pdfcpu_0.11.0_Windows_x86_64.zip" -OutFile $zipPath
          Expand-Archive -Path $zipPath -DestinationPath $toolsPath -Force
          Remove-Item $zipPath
          Write-Host "✅ pdfcpu downloaded"

      - name: Download QPDF
        shell: pwsh
        run: |
          $toolsPath = "./installer/tools/QPDF"
          New-Item -ItemType Directory -Path $toolsPath -Force | Out-Null
          
          $zipPath = Join-Path $env:TEMP "qpdf.zip"
          $tempExtract = Join-Path $env:TEMP "qpdf_extract"
          
          Invoke-WebRequest -Uri "https://github.com/qpdf/qpdf/releases/download/v12.0.0/qpdf-12.0.0-msvc64.zip" -OutFile $zipPath
          
          if (Test-Path $tempExtract) { Remove-Item -Recurse -Force $tempExtract }
          Expand-Archive -Path $zipPath -DestinationPath $tempExtract -Force
          
          $extractedDir = Get-ChildItem $tempExtract -Directory | Select-Object -First 1
          if ($extractedDir) {
            Copy-Item -Path "$($extractedDir.FullName)\*" -Destination $toolsPath -Recurse -Force
          }
          
          Remove-Item $zipPath -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force $tempExtract -ErrorAction SilentlyContinue
          Write-Host "✅ QPDF downloaded"

      - name: Download Tesseract OCR Data
        shell: pwsh
        run: |
          $toolsPath = "./installer/tools/TesseractOCR_Data"
          New-Item -ItemType Directory -Path $toolsPath -Force | Out-Null
          
          $zipPath = Join-Path $env:TEMP "tessdata.zip"
          Invoke-WebRequest -Uri "https://github.com/tesseract-ocr/tessdata_best/archive/refs/tags/4.1.0.zip" -OutFile $zipPath
          
          $tempExtract = Join-Path $env:TEMP "tessdata_extract"
          if (Test-Path $tempExtract) { Remove-Item -Recurse -Force $tempExtract }
          Expand-Archive -Path $zipPath -DestinationPath $tempExtract -Force
          
          $extractedDir = "$tempExtract\tessdata_best-4.1.0"
          Copy-Item "$extractedDir\eng.traineddata" $toolsPath -Force
          Copy-Item "$extractedDir\jpn.traineddata" $toolsPath -Force
          
          Remove-Item $zipPath -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force $tempExtract -ErrorAction SilentlyContinue
          Write-Host "✅ Tesseract OCR Data downloaded"

      - name: Install Inno Setup
        shell: pwsh
        run: |
          choco install innosetup -y --no-progress
          Write-Host "✅ Inno Setup installed"

      - name: Build Installer
        shell: pwsh
        run: |
          $issPath = "./installer/SuperBookTools.iss"
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" $issPath
          Write-Host "✅ Installer built"

      - name: Upload Installer
        uses: actions/upload-artifact@v4
        with:
          name: SuperBookTools-Installer
          path: ./installer_output/SuperBookTools_Setup_*.exe
          retention-days: 30

  # デプロイジョブ（セルフホストランナー）
  deploy:
    runs-on: self-hosted
    needs: build
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event.inputs.action != 'rollback'
    timeout-minutes: 15

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: SuperBookToolsApp-win-x64
          path: ./artifacts

      - name: Display downloaded files
        shell: pwsh
        run: |
          Write-Host "Downloaded artifacts:"
          Get-ChildItem -Recurse ./artifacts | Format-Table FullName, Length

      - name: Stop running application (if exists)
        shell: pwsh
        run: |
          $processName = "SuperBookToolsApp"
          $process = Get-Process -Name $processName -ErrorAction SilentlyContinue
          if ($process) {
            Write-Host "Stopping $processName..."
            Stop-Process -Name $processName -Force
            Start-Sleep -Seconds 2
          } else {
            Write-Host "$processName is not running."
          }

      - name: Backup existing deployment
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $backupPath = "${{ env.BACKUP_PATH }}"
          
          if (Test-Path $deployPath) {
            Write-Host "Backing up existing deployment..."
            
            # 既存のバックアップを削除
            if (Test-Path $backupPath) {
              Remove-Item -Recurse -Force $backupPath
            }
            
            # 現在のデプロイをバックアップ
            Copy-Item -Recurse -Force $deployPath $backupPath
            Write-Host "Backup completed to $backupPath"
          } else {
            Write-Host "No existing deployment found. Skipping backup."
          }

      - name: Deploy to local folder
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $sourcePath = "./artifacts"
          
          Write-Host "Deploying to $deployPath..."
          
          # デプロイ先フォルダを作成（存在しない場合）
          if (-not (Test-Path $deployPath)) {
            New-Item -ItemType Directory -Path $deployPath -Force | Out-Null
          }
          
          # ファイルをコピー
          Copy-Item -Recurse -Force "$sourcePath\*" $deployPath
          
          Write-Host "Deployment completed successfully!"
          Write-Host "Files deployed:"
          Get-ChildItem $deployPath | Format-Table Name, Length, LastWriteTime

      - name: Setup external tools directory
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $toolsPath = Join-Path $deployPath "external_tools\image_tools"
          
          # ディレクトリ構造を作成
          $subDirs = @(
            "exiftool-13.30_64",
            "ImageMagick-portable-Q16-HDRI-x64",
            "pdfcpu",
            "QPDF",
            "RealEsrgan\RealEsrgan_Repo",
            "yomitoku",
            "TesseractOCR_Data"
          )
          
          foreach ($dir in $subDirs) {
            $fullPath = Join-Path $toolsPath $dir
            if (-not (Test-Path $fullPath)) {
              New-Item -ItemType Directory -Path $fullPath -Force | Out-Null
              Write-Host "Created: $fullPath"
            }
          }

      - name: Download and setup ExifTool
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\image_tools\exiftool-13.30_64"
          $exePath = Join-Path $toolsPath "exiftool.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "Downloading ExifTool..."
            $zipPath = Join-Path $env:TEMP "exiftool.zip"
            $tempExtract = Join-Path $env:TEMP "exiftool_extract"
            
            # 一時フォルダをクリーンアップ
            if (Test-Path $tempExtract) {
              Remove-Item -Recurse -Force $tempExtract
            }
            New-Item -ItemType Directory -Path $tempExtract -Force | Out-Null
            
            Invoke-WebRequest -Uri "https://filecenter.softether-upload.com/d/260118_003_73929/exiftool-13.30_64.zip" -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $tempExtract -Force
            
            # ZIPの中にサブフォルダがある場合、その中身をコピー
            $extractedSubDir = Join-Path $tempExtract "exiftool-13.30_64"
            if (Test-Path $extractedSubDir) {
              Write-Host "Moving files from nested folder..."
              Copy-Item -Path "$extractedSubDir\*" -Destination $toolsPath -Recurse -Force
            } else {
              Copy-Item -Path "$tempExtract\*" -Destination $toolsPath -Recurse -Force
            }
            
            # exiftool(-k).exe を exiftool.exe にリネーム
            $srcExe = Join-Path $toolsPath "exiftool(-k).exe"
            if (Test-Path $srcExe) {
              Write-Host "Renaming exiftool(-k).exe to exiftool.exe..."
              Rename-Item -Path $srcExe -NewName "exiftool.exe" -Force
            }
            
            # クリーンアップ
            Remove-Item $zipPath -ErrorAction SilentlyContinue
            Remove-Item -Recurse -Force $tempExtract -ErrorAction SilentlyContinue
            
            Write-Host "✅ ExifTool installed"
            Get-ChildItem $toolsPath | Format-Table Name
          } else {
            Write-Host "ℹ️ ExifTool already exists"
          }

      - name: Download and setup ImageMagick
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\image_tools\ImageMagick-portable-Q16-HDRI-x64"
          $exePath = Join-Path $toolsPath "magick.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "Downloading ImageMagick..."
            
            # ImageMagickのバイナリ一覧ページから最新のportable版を検索
            $binariesUrl = "https://imagemagick.org/archive/binaries/"
            try {
              $response = Invoke-WebRequest -Uri $binariesUrl -UseBasicParsing
              $content = $response.Content
              
              # ImageMagick-7.1.x-portable-Q16-HDRI-x64.7z を検索
              $pattern = 'ImageMagick-7\.1\.[\d\-]+-portable-Q16-HDRI-x64\.7z'
              $matches7z = [regex]::Matches($content, $pattern)
              
              if ($matches7z.Count -gt 0) {
                $fileName = $matches7z[$matches7z.Count - 1].Value
                Write-Host "Found: $fileName"
              } else {
                throw "Could not find ImageMagick 7.1.x portable version"
              }
              $downloadUrl = "$binariesUrl$fileName"
            } catch {
              Write-Host "⚠️ Could not detect latest version, using fallback..."
              $fileName = "ImageMagick-7.1.2-13-portable-Q16-HDRI-x64.7z"
              $downloadUrl = "$binariesUrl$fileName"
            }
            
            $downloadPath = Join-Path $env:TEMP $fileName
            Write-Host "Downloading from: $downloadUrl"
            Invoke-WebRequest -Uri $downloadUrl -OutFile $downloadPath
            
            # bsdtar (libarchive) で展開（Windows 10 1903以降、.7z対応）
            tar -xf $downloadPath -C $toolsPath
            
            Remove-Item $downloadPath -ErrorAction SilentlyContinue
            Write-Host "✅ ImageMagick installed"
          } else {
            Write-Host "ℹ️ ImageMagick already exists"
          }

      - name: Download and setup Ghostscript
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\image_tools\ImageMagick-portable-Q16-HDRI-x64"
          $dllPath = Join-Path $toolsPath "gsdll64.dll"
          
          if (-not (Test-Path $dllPath)) {
            Write-Host "Checking Ghostscript installation..."
            $gsPath = "C:\Program Files\gs\gs10.05.1\bin"
            
            if (Test-Path $gsPath) {
              Write-Host "Copying Ghostscript files from $gsPath..."
              Copy-Item "$gsPath\gsdll64.dll" $toolsPath -Force
              Copy-Item "$gsPath\gsdll64.lib" $toolsPath -Force -ErrorAction SilentlyContinue
              Copy-Item "$gsPath\gswin64.exe" $toolsPath -Force
              Copy-Item "$gsPath\gswin64c.exe" $toolsPath -Force
              Write-Host "✅ Ghostscript files copied"
            } else {
              Write-Host "⚠️ Ghostscript not found at $gsPath. Please install manually."
            }
          } else {
            Write-Host "ℹ️ Ghostscript already exists"
          }

      - name: Download and setup pdfcpu
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\image_tools\pdfcpu"
          $exePath = Join-Path $toolsPath "pdfcpu.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "Downloading pdfcpu..."
            $zipPath = Join-Path $env:TEMP "pdfcpu.zip"
            Invoke-WebRequest -Uri "https://github.com/pdfcpu/pdfcpu/releases/download/v0.11.0/pdfcpu_0.11.0_Windows_x86_64.zip" -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $toolsPath -Force
            Remove-Item $zipPath
            Write-Host "✅ pdfcpu installed"
          } else {
            Write-Host "ℹ️ pdfcpu already exists"
          }

      - name: Download and setup QPDF
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\image_tools\QPDF"
          $exePath = Join-Path $toolsPath "bin\qpdf.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "Downloading QPDF..."
            $zipPath = Join-Path $env:TEMP "qpdf.zip"
            Invoke-WebRequest -Uri "https://github.com/qpdf/qpdf/releases/download/v11.9.1/qpdf-11.9.1-msvc64.zip" -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $env:TEMP\qpdf_extract -Force
            # 展開されたディレクトリの中身をコピー
            $extractedDir = Get-ChildItem "$env:TEMP\qpdf_extract" -Directory | Select-Object -First 1
            Copy-Item "$($extractedDir.FullName)\*" $toolsPath -Recurse -Force
            Remove-Item $zipPath
            Remove-Item "$env:TEMP\qpdf_extract" -Recurse -Force
            Write-Host "✅ QPDF installed"
          } else {
            Write-Host "ℹ️ QPDF already exists"
          }

      - name: Download and setup Tesseract OCR Data
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\image_tools\TesseractOCR_Data"
          $engPath = Join-Path $toolsPath "eng.traineddata"
          
          if (-not (Test-Path $engPath)) {
            Write-Host "Downloading Tesseract OCR Data..."
            $zipPath = Join-Path $env:TEMP "tessdata.zip"
            Invoke-WebRequest -Uri "https://github.com/tesseract-ocr/tessdata_best/archive/4.1.0.zip" -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $env:TEMP\tessdata_extract -Force
            # 必要なファイルのみコピー
            $extractedDir = "$env:TEMP\tessdata_extract\tessdata_best-4.1.0"
            Copy-Item "$extractedDir\eng.traineddata" $toolsPath -Force
            Copy-Item "$extractedDir\jpn.traineddata" $toolsPath -Force
            Remove-Item $zipPath
            Remove-Item "$env:TEMP\tessdata_extract" -Recurse -Force
            Write-Host "✅ Tesseract OCR Data installed"
          } else {
            Write-Host "ℹ️ Tesseract OCR Data already exists"
          }

      - name: Cleanup Python environments before setup
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          
          # RealEsrgan削除
          $realEsrganPath = Join-Path $deployPath "external_tools\image_tools\RealEsrgan"
          if (Test-Path $realEsrganPath) {
            Write-Host "Removing RealEsrgan..."
            Remove-Item -Recurse -Force $realEsrganPath
          }
          
          # YomiToku削除
          $yomitokuPath = Join-Path $deployPath "external_tools\image_tools\yomitoku"
          if (Test-Path $yomitokuPath) {
            Write-Host "Removing YomiToku..."
            Remove-Item -Recurse -Force $yomitokuPath
          }
          
          Write-Host "✅ Cleanup completed"

      - name: Setup RealEsrgan (Python environment)
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\image_tools\RealEsrgan\RealEsrgan_Repo"
          $venvPath = Join-Path $toolsPath "venv"
          
          if (-not (Test-Path $venvPath)) {
            Write-Host "Setting up RealEsrgan Python environment..."
            
            # Pythonを検索
            $pythonPath = $null
            
            # PATHから検索
            $pythonCmd = Get-Command python -ErrorAction SilentlyContinue
            if ($pythonCmd) {
              $pythonPath = $pythonCmd.Source
            }
            
            # py ランチャーから検索
            if (-not $pythonPath) {
              $pyCmd = Get-Command py -ErrorAction SilentlyContinue
              if ($pyCmd) {
                $pythonPath = "py"
              }
            }
            
            if ($pythonPath) {
              Write-Host "Found Python at: $pythonPath"
              
              # venv作成
              if ($pythonPath -eq "py") {
                & py -3 -m venv $venvPath
              } else {
                & $pythonPath -m venv $venvPath
              }
              
              # 依存関係インストール
              $activateScript = Join-Path $venvPath "Scripts\Activate.ps1"
              & $activateScript
              
              & "$venvPath\Scripts\python.exe" -m pip install --upgrade pip
              & "$venvPath\Scripts\pip.exe" install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/${{ env.PYTORCH_CUDA_VERSION }}
              
              # Real-ESRGANリポジトリをクローン
              $repoPath = Join-Path $toolsPath "Real-ESRGAN"
              if (-not (Test-Path $repoPath)) {
                git clone https://github.com/xinntao/Real-ESRGAN.git $repoPath
                Push-Location $repoPath
                git checkout a4abfb2979a7bbff3f69f58f58ae324608821e27
                Pop-Location
              }
              
              # weightsディレクトリ作成とモデルダウンロード
              $weightsPath = Join-Path $repoPath "weights"
              if (-not (Test-Path $weightsPath)) {
                New-Item -ItemType Directory -Path $weightsPath -Force | Out-Null
              }
              $modelPath = Join-Path $weightsPath "RealESRGAN_x4plus.pth"
              if (-not (Test-Path $modelPath)) {
                Write-Host "Downloading RealESRGAN model..."
                Invoke-WebRequest -Uri "https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.0/RealESRGAN_x4plus.pth" -OutFile $modelPath
              }
              
              # requirements.txtインストール
              $reqPath = Join-Path $repoPath "requirements.txt"
              if (Test-Path $reqPath) {
                & "$venvPath\Scripts\pip.exe" install -r $reqPath
              }
              
              # degradations.pyのパッチ
              $degradationsPath = Join-Path $venvPath "Lib\site-packages\basicsr\data\degradations.py"
              if (Test-Path $degradationsPath) {
                $content = Get-Content $degradationsPath -Raw
                $content = $content -replace 'from torchvision.transforms.functional_tensor import rgb_to_grayscale', 'from torchvision.transforms.functional import rgb_to_grayscale'
                Set-Content $degradationsPath $content
                Write-Host "✅ Patched degradations.py"
              }
              
              # version.py作成
              $versionPath = Join-Path $repoPath "realesrgan\version.py"
              if (-not (Test-Path $versionPath)) {
                New-Item -ItemType File -Path $versionPath -Force | Out-Null
              }
              
              Write-Host "✅ RealEsrgan setup completed"
            } else {
              Write-Host "⚠️ Python not found. Please install Python 3.11 or later and ensure it's in PATH."
            }
          } else {
            Write-Host "ℹ️ RealEsrgan already exists"
          }

      - name: Setup YomiToku (Python environment)
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\image_tools\yomitoku"
          $venvPath = Join-Path $toolsPath "venv"
          
          if (-not (Test-Path $venvPath)) {
            Write-Host "Setting up YomiToku Python environment..."
            
            # Pythonを検索
            $pythonPath = $null
            
            # PATHから検索
            $pythonCmd = Get-Command python -ErrorAction SilentlyContinue
            if ($pythonCmd) {
              $pythonPath = $pythonCmd.Source
            }
            
            # py ランチャーから検索
            if (-not $pythonPath) {
              $pyCmd = Get-Command py -ErrorAction SilentlyContinue
              if ($pyCmd) {
                $pythonPath = "py"
              }
            }
            
            if ($pythonPath) {
              Write-Host "Found Python at: $pythonPath"
              
              # venv作成
              if ($pythonPath -eq "py") {
                & py -3 -m venv $venvPath
              } else {
                & $pythonPath -m venv $venvPath
              }
              
              # 依存関係インストール
              & "$venvPath\Scripts\python.exe" -m pip install --upgrade pip
              & "$venvPath\Scripts\pip.exe" install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/${{ env.PYTORCH_CUDA_VERSION }}
              & "$venvPath\Scripts\pip.exe" install "yomitoku==0.10.3"
              
              Write-Host "✅ YomiToku setup completed"
            } else {
              Write-Host "⚠️ Python not found. Please install Python 3.11 or later and ensure it's in PATH."
            }
          } else {
            Write-Host "ℹ️ YomiToku already exists"
          }

      - name: Verify deployment
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $exePath = Join-Path $deployPath "SuperBookToolsApp.exe"
          
          if (Test-Path $exePath) {
            Write-Host "✅ Deployment verified successfully!"
            $fileInfo = Get-Item $exePath
            Write-Host "  Executable: $exePath"
            Write-Host "  Size: $($fileInfo.Length) bytes"
            Write-Host "  Modified: $($fileInfo.LastWriteTime)"
            Write-Host ""
            Write-Host "Usage: $exePath [arguments]"
          } else {
            Write-Error "❌ Deployment verification failed! Executable not found."
            exit 1
          }

  # ロールバックジョブ（手動実行用 - セルフホストランナー）
  rollback:
    runs-on: self-hosted
    if: github.event.inputs.action == 'rollback'
    timeout-minutes: 10

    steps:
      - name: Stop running application (if exists)
        shell: pwsh
        run: |
          $processName = "SuperBookToolsApp"
          $process = Get-Process -Name $processName -ErrorAction SilentlyContinue
          if ($process) {
            Write-Host "Stopping $processName..."
            Stop-Process -Name $processName -Force
            Start-Sleep -Seconds 2
          }

      - name: Rollback to previous version
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $backupPath = "${{ env.BACKUP_PATH }}"
          
          if (Test-Path $backupPath) {
            Write-Host "Rolling back to previous version..."
            
            # 現在のデプロイを削除
            if (Test-Path $deployPath) {
              Remove-Item -Recurse -Force $deployPath
            }
            
            # バックアップから復元
            Copy-Item -Recurse -Force $backupPath $deployPath
            
            Write-Host "✅ Rollback completed successfully!"
            Get-ChildItem $deployPath | Format-Table Name, Length, LastWriteTime
          } else {
            Write-Error "❌ No backup found at $backupPath. Cannot rollback."
            exit 1
          }
