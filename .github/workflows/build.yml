# GitHub Actions - Windows 11 ビルドワークフロー
# DN_SuperBook_PDF_Converter プロジェクト用
# ハイブリッド構成: GitHubランナー（ビルド）+ セルフホストランナー（デプロイ）

name: Build, Test and Deploy

on:
  push:
    branches:
      - "**"
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'build'
        type: choice
        options:
          - build
          - rollback

env:
  # デプロイ先フォルダ（セルフホストランナー上のパス）
  DEPLOY_PATH: 'C:\SuperBookTools'
  # バックアップフォルダ
  BACKUP_PATH: 'C:\SuperBookTools_Backup'
  # .NET バージョン
  DOTNET_VERSION: '6.0'

jobs:
  # ビルド・テストジョブ（GitHub提供ランナー）
  build:
    runs-on: windows-latest
    if: github.event.inputs.action != 'rollback'
    timeout-minutes: 30

    strategy:
      fail-fast: false
      matrix:
        configuration: [Debug, Release]

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup .NET SDK ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Display .NET version
        run: dotnet --version

      - name: Restore dependencies
        run: dotnet restore DN_SuperBook_PDF_Converter_VS2026.sln

      - name: Build ${{ matrix.configuration }}
        run: dotnet build -c ${{ matrix.configuration }} -v normal DN_SuperBook_PDF_Converter_VS2026.sln --no-restore

      - name: Test ${{ matrix.configuration }}
        run: dotnet test -c ${{ matrix.configuration }} -v normal --logger:"console;verbosity=detailed" DN_SuperBook_PDF_Converter_VS2026.sln --no-build
        continue-on-error: true

      # Releaseビルドのみ: 自己完結型パッケージを作成
      - name: Publish self-contained application
        if: matrix.configuration == 'Release'
        run: |
          dotnet publish SuperBookToolsApp/SuperBookToolsApp.csproj `
            -c Release `
            -r win-x64 `
            --self-contained true `
            -o ./publish/win-x64

      # Releaseビルドのみ: アーティファクトをアップロード
      - name: Upload build artifacts
        if: matrix.configuration == 'Release'
        uses: actions/upload-artifact@v4
        with:
          name: SuperBookToolsApp-win-x64
          path: ./publish/win-x64/
          retention-days: 30

  # デプロイジョブ（セルフホストランナー）
  deploy:
    runs-on: self-hosted
    needs: build
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event.inputs.action != 'rollback'
    timeout-minutes: 15

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: SuperBookToolsApp-win-x64
          path: ./artifacts

      - name: Display downloaded files
        shell: pwsh
        run: |
          Write-Host "Downloaded artifacts:"
          Get-ChildItem -Recurse ./artifacts | Format-Table FullName, Length

      - name: Stop running application (if exists)
        shell: pwsh
        run: |
          $processName = "SuperBookToolsApp"
          $process = Get-Process -Name $processName -ErrorAction SilentlyContinue
          if ($process) {
            Write-Host "Stopping $processName..."
            Stop-Process -Name $processName -Force
            Start-Sleep -Seconds 2
          } else {
            Write-Host "$processName is not running."
          }

      - name: Backup existing deployment
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $backupPath = "${{ env.BACKUP_PATH }}"
          
          if (Test-Path $deployPath) {
            Write-Host "Backing up existing deployment..."
            
            # 既存のバックアップを削除
            if (Test-Path $backupPath) {
              Remove-Item -Recurse -Force $backupPath
            }
            
            # 現在のデプロイをバックアップ
            Copy-Item -Recurse -Force $deployPath $backupPath
            Write-Host "Backup completed to $backupPath"
          } else {
            Write-Host "No existing deployment found. Skipping backup."
          }

      - name: Deploy to local folder
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $sourcePath = "./artifacts"
          
          Write-Host "Deploying to $deployPath..."
          
          # デプロイ先フォルダを作成（存在しない場合）
          if (-not (Test-Path $deployPath)) {
            New-Item -ItemType Directory -Path $deployPath -Force | Out-Null
          }
          
          # ファイルをコピー
          Copy-Item -Recurse -Force "$sourcePath\*" $deployPath
          
          Write-Host "Deployment completed successfully!"
          Write-Host "Files deployed:"
          Get-ChildItem $deployPath | Format-Table Name, Length, LastWriteTime

      - name: Setup external tools directory
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $toolsPath = Join-Path $deployPath "external_tools\external_tools\image_tools"
          
          # ディレクトリ構造を作成
          $subDirs = @(
            "exiftool-13.30_64",
            "ImageMagick-portable-Q16-HDRI-x64",
            "pdfcpu",
            "QPDF",
            "RealEsrgan\RealEsrgan_Repo",
            "yomitoku",
            "TesseractOCR_Data"
          )
          
          foreach ($dir in $subDirs) {
            $fullPath = Join-Path $toolsPath $dir
            if (-not (Test-Path $fullPath)) {
              New-Item -ItemType Directory -Path $fullPath -Force | Out-Null
              Write-Host "Created: $fullPath"
            }
          }

      - name: Download and setup ExifTool
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\external_tools\image_tools\exiftool-13.30_64"
          $exePath = Join-Path $toolsPath "exiftool.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "Downloading ExifTool..."
            $zipPath = Join-Path $env:TEMP "exiftool.zip"
            Invoke-WebRequest -Uri "https://filecenter.softether-upload.com/d/260118_003_73929/exiftool-13.30_64.zip" -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $toolsPath -Force
            Remove-Item $zipPath
            Write-Host "✅ ExifTool installed"
          } else {
            Write-Host "ℹ️ ExifTool already exists"
          }

      - name: Download and setup ImageMagick
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\external_tools\image_tools\ImageMagick-portable-Q16-HDRI-x64"
          $exePath = Join-Path $toolsPath "magick.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "Downloading ImageMagick..."
            
            # ImageMagickのバイナリ一覧ページから最新のportable版を検索
            $binariesUrl = "https://imagemagick.org/archive/binaries/"
            try {
              $response = Invoke-WebRequest -Uri $binariesUrl -UseBasicParsing
              $content = $response.Content
              
              # portable-Q16-HDRI-x64 の .zip ファイルを優先検索（標準コマンドで展開可能）
              $patternZip = 'ImageMagick-[\d\.]+-portable-Q16-HDRI-x64\.zip'
              $matchesZip = [regex]::Matches($content, $patternZip)
              
              if ($matchesZip.Count -gt 0) {
                $fileName = $matchesZip[$matchesZip.Count - 1].Value
                Write-Host "Found ZIP version: $fileName"
              } else {
                # .zipがない場合は.7zを探す
                $pattern7z = 'ImageMagick-[\d\.]+-portable-Q16-HDRI-x64\.7z'
                $matches7z = [regex]::Matches($content, $pattern7z)
                if ($matches7z.Count -gt 0) {
                  $fileName = $matches7z[$matches7z.Count - 1].Value
                  Write-Host "Found 7z version: $fileName"
                } else {
                  throw "Could not find ImageMagick portable version"
                }
              }
              $downloadUrl = "$binariesUrl$fileName"
            } catch {
              Write-Host "⚠️ Could not detect latest version, using fallback..."
              $fileName = "ImageMagick-7.1.2-13-portable-Q16-HDRI-x64.zip"
              $downloadUrl = "$binariesUrl$fileName"
            }
            
            $downloadPath = Join-Path $env:TEMP $fileName
            Write-Host "Downloading from: $downloadUrl"
            Invoke-WebRequest -Uri $downloadUrl -OutFile $downloadPath
            
            # bsdtar (libarchive) で展開（Windows 10 1903以降、.zip/.7z両対応）
            tar -xf $downloadPath -C $toolsPath
            
            Remove-Item $downloadPath -ErrorAction SilentlyContinue
            Write-Host "✅ ImageMagick installed"
          } else {
            Write-Host "ℹ️ ImageMagick already exists"
          }

      - name: Download and setup Ghostscript
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\external_tools\image_tools\ImageMagick-portable-Q16-HDRI-x64"
          $dllPath = Join-Path $toolsPath "gsdll64.dll"
          
          if (-not (Test-Path $dllPath)) {
            Write-Host "Checking Ghostscript installation..."
            $gsPath = "C:\Program Files\gs\gs10.05.1\bin"
            
            if (Test-Path $gsPath) {
              Write-Host "Copying Ghostscript files from $gsPath..."
              Copy-Item "$gsPath\gsdll64.dll" $toolsPath -Force
              Copy-Item "$gsPath\gsdll64.lib" $toolsPath -Force -ErrorAction SilentlyContinue
              Copy-Item "$gsPath\gswin64.exe" $toolsPath -Force
              Copy-Item "$gsPath\gswin64c.exe" $toolsPath -Force
              Write-Host "✅ Ghostscript files copied"
            } else {
              Write-Host "⚠️ Ghostscript not found at $gsPath. Please install manually."
            }
          } else {
            Write-Host "ℹ️ Ghostscript already exists"
          }

      - name: Download and setup pdfcpu
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\external_tools\image_tools\pdfcpu"
          $exePath = Join-Path $toolsPath "pdfcpu.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "Downloading pdfcpu..."
            $zipPath = Join-Path $env:TEMP "pdfcpu.zip"
            Invoke-WebRequest -Uri "https://github.com/pdfcpu/pdfcpu/releases/download/v0.11.0/pdfcpu_0.11.0_Windows_x86_64.zip" -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $toolsPath -Force
            Remove-Item $zipPath
            Write-Host "✅ pdfcpu installed"
          } else {
            Write-Host "ℹ️ pdfcpu already exists"
          }

      - name: Download and setup QPDF
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\external_tools\image_tools\QPDF"
          $exePath = Join-Path $toolsPath "bin\qpdf.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "Downloading QPDF..."
            $zipPath = Join-Path $env:TEMP "qpdf.zip"
            Invoke-WebRequest -Uri "https://github.com/qpdf/qpdf/releases/download/v11.9.1/qpdf-11.9.1-msvc64.zip" -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $env:TEMP\qpdf_extract -Force
            # 展開されたディレクトリの中身をコピー
            $extractedDir = Get-ChildItem "$env:TEMP\qpdf_extract" -Directory | Select-Object -First 1
            Copy-Item "$($extractedDir.FullName)\*" $toolsPath -Recurse -Force
            Remove-Item $zipPath
            Remove-Item "$env:TEMP\qpdf_extract" -Recurse -Force
            Write-Host "✅ QPDF installed"
          } else {
            Write-Host "ℹ️ QPDF already exists"
          }

      - name: Download and setup Tesseract OCR Data
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\external_tools\image_tools\TesseractOCR_Data"
          $engPath = Join-Path $toolsPath "eng.traineddata"
          
          if (-not (Test-Path $engPath)) {
            Write-Host "Downloading Tesseract OCR Data..."
            $zipPath = Join-Path $env:TEMP "tessdata.zip"
            Invoke-WebRequest -Uri "https://github.com/tesseract-ocr/tessdata_best/archive/4.1.0.zip" -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $env:TEMP\tessdata_extract -Force
            # 必要なファイルのみコピー
            $extractedDir = "$env:TEMP\tessdata_extract\tessdata_best-4.1.0"
            Copy-Item "$extractedDir\eng.traineddata" $toolsPath -Force
            Copy-Item "$extractedDir\jpn.traineddata" $toolsPath -Force
            Remove-Item $zipPath
            Remove-Item "$env:TEMP\tessdata_extract" -Recurse -Force
            Write-Host "✅ Tesseract OCR Data installed"
          } else {
            Write-Host "ℹ️ Tesseract OCR Data already exists"
          }

      - name: Setup RealEsrgan (Python environment)
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\external_tools\image_tools\RealEsrgan\RealEsrgan_Repo"
          $venvPath = Join-Path $toolsPath "venv"
          
          if (-not (Test-Path $venvPath)) {
            Write-Host "Setting up RealEsrgan Python environment..."
            
            # Pythonを検索
            $pythonPath = $null
            
            # PATHから検索
            $pythonCmd = Get-Command python -ErrorAction SilentlyContinue
            if ($pythonCmd) {
              $pythonPath = $pythonCmd.Source
            }
            
            # py ランチャーから検索
            if (-not $pythonPath) {
              $pyCmd = Get-Command py -ErrorAction SilentlyContinue
              if ($pyCmd) {
                $pythonPath = "py"
              }
            }
            
            if ($pythonPath) {
              Write-Host "Found Python at: $pythonPath"
              
              # venv作成
              if ($pythonPath -eq "py") {
                & py -3 -m venv $venvPath
              } else {
                & $pythonPath -m venv $venvPath
              }
              
              # 依存関係インストール
              $activateScript = Join-Path $venvPath "Scripts\Activate.ps1"
              & $activateScript
              
              & "$venvPath\Scripts\python.exe" -m pip install --upgrade pip
              & "$venvPath\Scripts\pip.exe" install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu128
              
              # Real-ESRGANリポジトリをクローン
              $repoPath = Join-Path $toolsPath "Real-ESRGAN"
              if (-not (Test-Path $repoPath)) {
                git clone https://github.com/xinntao/Real-ESRGAN.git $repoPath
                Push-Location $repoPath
                git checkout a4abfb2979a7bbff3f69f58f58ae324608821e27
                Pop-Location
              }
              
              # weightsディレクトリ作成とモデルダウンロード
              $weightsPath = Join-Path $repoPath "weights"
              if (-not (Test-Path $weightsPath)) {
                New-Item -ItemType Directory -Path $weightsPath -Force | Out-Null
              }
              $modelPath = Join-Path $weightsPath "RealESRGAN_x4plus.pth"
              if (-not (Test-Path $modelPath)) {
                Write-Host "Downloading RealESRGAN model..."
                Invoke-WebRequest -Uri "https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.0/RealESRGAN_x4plus.pth" -OutFile $modelPath
              }
              
              # requirements.txtインストール
              $reqPath = Join-Path $repoPath "requirements.txt"
              if (Test-Path $reqPath) {
                & "$venvPath\Scripts\pip.exe" install -r $reqPath
              }
              
              # degradations.pyのパッチ
              $degradationsPath = Join-Path $venvPath "Lib\site-packages\basicsr\data\degradations.py"
              if (Test-Path $degradationsPath) {
                $content = Get-Content $degradationsPath -Raw
                $content = $content -replace 'from torchvision.transforms.functional_tensor import rgb_to_grayscale', 'from torchvision.transforms.functional import rgb_to_grayscale'
                Set-Content $degradationsPath $content
                Write-Host "✅ Patched degradations.py"
              }
              
              # version.py作成
              $versionPath = Join-Path $repoPath "realesrgan\version.py"
              if (-not (Test-Path $versionPath)) {
                New-Item -ItemType File -Path $versionPath -Force | Out-Null
              }
              
              Write-Host "✅ RealEsrgan setup completed"
            } else {
              Write-Host "⚠️ Python not found. Please install Python 3.11 or later and ensure it's in PATH."
            }
          } else {
            Write-Host "ℹ️ RealEsrgan already exists"
          }

      - name: Setup YomiToku (Python environment)
        shell: pwsh
        run: |
          $toolsPath = Join-Path "${{ env.DEPLOY_PATH }}" "external_tools\external_tools\image_tools\yomitoku"
          $venvPath = Join-Path $toolsPath "venv"
          
          if (-not (Test-Path $venvPath)) {
            Write-Host "Setting up YomiToku Python environment..."
            
            # Pythonを検索
            $pythonPath = $null
            
            # PATHから検索
            $pythonCmd = Get-Command python -ErrorAction SilentlyContinue
            if ($pythonCmd) {
              $pythonPath = $pythonCmd.Source
            }
            
            # py ランチャーから検索
            if (-not $pythonPath) {
              $pyCmd = Get-Command py -ErrorAction SilentlyContinue
              if ($pyCmd) {
                $pythonPath = "py"
              }
            }
            
            if ($pythonPath) {
              Write-Host "Found Python at: $pythonPath"
              
              # venv作成
              if ($pythonPath -eq "py") {
                & py -3 -m venv $venvPath
              } else {
                & $pythonPath -m venv $venvPath
              }
              
              # 依存関係インストール
              & "$venvPath\Scripts\python.exe" -m pip install --upgrade pip
              & "$venvPath\Scripts\pip.exe" install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu128
              & "$venvPath\Scripts\pip.exe" install "yomitoku==0.10.3"
              
              Write-Host "✅ YomiToku setup completed"
            } else {
              Write-Host "⚠️ Python not found. Please install Python 3.11 or later and ensure it's in PATH."
            }
          } else {
            Write-Host "ℹ️ YomiToku already exists"
          }

      - name: Verify deployment
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $exePath = Join-Path $deployPath "SuperBookToolsApp.exe"
          
          if (Test-Path $exePath) {
            Write-Host "✅ Deployment verified successfully!"
            $fileInfo = Get-Item $exePath
            Write-Host "  Executable: $exePath"
            Write-Host "  Size: $($fileInfo.Length) bytes"
            Write-Host "  Modified: $($fileInfo.LastWriteTime)"
            Write-Host ""
            Write-Host "Usage: $exePath [arguments]"
          } else {
            Write-Error "❌ Deployment verification failed! Executable not found."
            exit 1
          }

  # ロールバックジョブ（手動実行用 - セルフホストランナー）
  rollback:
    runs-on: self-hosted
    if: github.event.inputs.action == 'rollback'
    timeout-minutes: 10

    steps:
      - name: Stop running application (if exists)
        shell: pwsh
        run: |
          $processName = "SuperBookToolsApp"
          $process = Get-Process -Name $processName -ErrorAction SilentlyContinue
          if ($process) {
            Write-Host "Stopping $processName..."
            Stop-Process -Name $processName -Force
            Start-Sleep -Seconds 2
          }

      - name: Rollback to previous version
        shell: pwsh
        run: |
          $deployPath = "${{ env.DEPLOY_PATH }}"
          $backupPath = "${{ env.BACKUP_PATH }}"
          
          if (Test-Path $backupPath) {
            Write-Host "Rolling back to previous version..."
            
            # 現在のデプロイを削除
            if (Test-Path $deployPath) {
              Remove-Item -Recurse -Force $deployPath
            }
            
            # バックアップから復元
            Copy-Item -Recurse -Force $backupPath $deployPath
            
            Write-Host "✅ Rollback completed successfully!"
            Get-ChildItem $deployPath | Format-Table Name, Length, LastWriteTime
          } else {
            Write-Error "❌ No backup found at $backupPath. Cannot rollback."
            exit 1
          }
